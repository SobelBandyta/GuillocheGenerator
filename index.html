<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Guilloché Pattern Generator</title>
  <style>
    /* ... (pomiń dla zwięzłości) ... */
  </style>
</head>
<body>
  <div id="controlsContainer">
    <!-- ... pozostałe kontrolki ... -->
    <button id="saveSvgButton">Save as SVG</button>
  </div>

  <canvas id="canvas" width="600" height="600"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const patternTypeSelect = document.getElementById('patternType');
    const densitySlider = document.getElementById('density');
    const saveSvgButton = document.getElementById('saveSvgButton');

    const wavyFreq = document.getElementById('wavyFreq');
    const wavyAmp = document.getElementById('wavyAmp');
    const wavyOffsetX = document.getElementById('wavyOffsetX');
    const wavyOffsetY = document.getElementById('wavyOffsetY');

    function drawWavyRadial(ctx, cx, cy, radius, count, waveFreq, waveAmp, offsetX, offsetY) {
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 1;
      const steps = 100;
      for (let i = 0; i < count; i++) {
        const angle = (2 * Math.PI * i) / count;
        ctx.beginPath();
        let first = true;
        for (let j = 0; j <= steps; j++) {
          const t = j / steps;
          const baseR = radius * t;
          const waveOffset = Math.sin(t * waveFreq * 2 * Math.PI) * waveAmp;
          const r = baseR + waveOffset;
          const x = cx + offsetX + r * Math.cos(angle);
          const y = cy + offsetY + r * Math.sin(angle);
          if (first) {
            ctx.moveTo(x, y);
            first = false;
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }
    }

    function generateWavyRadialSVG(cx, cy, radius, count, waveFreq, waveAmp, offsetX, offsetY) {
      let svgCode = '';
      const steps = 100;
      for (let i = 0; i < count; i++) {
        const angle = (2 * Math.PI * i) / count;
        let dPath = '';
        let first = true;
        for (let j = 0; j <= steps; j++) {
          const t = j / steps;
          const baseR = radius * t;
          const waveOffset = Math.sin(t * waveFreq * 2 * Math.PI) * waveAmp;
          const r = baseR + waveOffset;
          const x = cx + offsetX + r * Math.cos(angle);
          const y = cy + offsetY + r * Math.sin(angle);
          if (first) {
            dPath += `M ${x} ${y}`;
            first = false;
          } else {
            dPath += ` L ${x} ${y}`;
          }
        }
        svgCode += `<path d="${dPath}" stroke="blue" stroke-width="1" fill="none"/>\`;
      }
      return svgCode;
    }

    function generateSVG() {
      const cx = 300;
      const cy = 300;
      const baseRadius = 250;
      const pattern = patternTypeSelect.value;
      const density = parseFloat(densitySlider.value);

      let svgString = `<?xml version="1.0" encoding="UTF-8"?>\n`;
      svgString += `<svg width="600" height="600" xmlns="http://www.w3.org/2000/svg">\n`;

      if (pattern === 'pattern17') {
        const wf = parseFloat(wavyFreq.value);
        const wa = parseFloat(wavyAmp.value);
        const ox = parseFloat(wavyOffsetX.value);
        const oy = parseFloat(wavyOffsetY.value);
        svgString += generateWavyRadialSVG(cx, cy, baseRadius, density, wf, wa, ox, oy);
      }

      svgString += `</svg>`;
      return svgString;
    }

    function saveSvg() {
      const svgData = generateSVG();
      const blob = new Blob([svgData], { type: "image/svg+xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "guilloche_wavy_radial.svg";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function draw() {
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const baseRadius = 250;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const pattern = patternTypeSelect.value;
      const density = parseFloat(densitySlider.value);

      switch (pattern) {
        case 'pattern17':
          const wf = parseFloat(wavyFreq.value);
          const wa = parseFloat(wavyAmp.value);
          const ox = parseFloat(wavyOffsetX.value);
          const oy = parseFloat(wavyOffsetY.value);
          drawWavyRadial(ctx, cx, cy, baseRadius, density, wf, wa, ox, oy);
          break;
      }
    }

    saveSvgButton.addEventListener('click', saveSvg);
    patternTypeSelect.addEventListener('change', () => {
      updateExtraControls();
      draw();
    });
    densitySlider.addEventListener('input', draw);

    wavyFreq.addEventListener('input', () => {
      document.getElementById('wavyFreqVal').textContent = wavyFreq.value;
      draw();
    });
    wavyAmp.addEventListener('input', () => {
      document.getElementById('wavyAmpVal').textContent = wavyAmp.value;
      draw();
    });
    wavyOffsetX.addEventListener('input', () => {
      document.getElementById('wavyOffsetXVal').textContent = wavyOffsetX.value;
      draw();
    });
    wavyOffsetY.addEventListener('input', () => {
      document.getElementById('wavyOffsetYVal').textContent = wavyOffsetY.value;
      draw();
    });

    function updateExtraControls() {
      const p = patternTypeSelect.value;
      document.getElementById('wavyRadialControls').style.display = (p === 'pattern17') ? "block" : "none";
    }

    window.onload = () => {
      updateExtraControls();
      draw();
    };
  </script>
</body>
</html>
